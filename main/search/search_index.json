{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KerasCustom","text":"<p>\ud83e\udde9 Custom layers and operations for Keras 3, designed to extend its capabilities with modular, composable components.</p>"},{"location":"#overview","title":"\ud83c\udf1f Overview","text":"<p>KerasCustom provides advanced and non-native Keras layers and operations that simplify the definition, transformation, and manipulation of neural network architectures. It is built to integrate seamlessly with the Keras Core backend system (TensorFlow, JAX, or PyTorch).</p> <p>This library is part of a broader ecosystem including:</p> <ul> <li>JacobiNet \u2013 for Jacobian computation as a Keras layer</li> <li>Decomon \u2013 for LiRPA / formal verification methods</li> <li>Onnx2Keras3 \u2013 for ONNX-to-Keras model conversion</li> <li>Keras2Marabou \u2013 for expressing verification properties</li> <li>Airobas \u2013 for end-to-end formal verification pipelines</li> </ul> <pre><code>---\nmaxdepth: 2\ncaption: Contents\n---\ninstall\ngetting_started\ntutorials\napi/modules\ncontribute\nGithub  &lt;https://github.com/ducoffeM/keras_custom&gt;\n</code></pre>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<p>```bash pip install git+https://github.com/ducoffeM/keras_custom.git</p>"},{"location":"#summary-of-keras_custom-functions","title":"\ud83d\udcca Summary of <code>keras_custom</code> Functions","text":"Category Functions Array Creation &amp; Manipulation <code>append</code>, <code>arange</code>, <code>diag</code>, <code>diagonal</code>, <code>expand_dims</code>, <code>flip</code>, <code>full_like</code>, <code>get_item</code>, <code>hstack</code>, <code>identity</code>, <code>moveaxis</code>, <code>ones_like</code>, <code>repeat</code>, <code>roll</code>, <code>sort</code>, <code>split</code>, <code>squeeze</code>, <code>stack</code>, <code>swapaxes</code>, <code>transpose</code>, <code>tril</code>, <code>triu</code>, <code>zeros_like</code> Mathematical Operations <code>abs</code>, <code>absolute</code>, <code>add</code>, <code>ceil</code>, <code>clip</code>, <code>divide</code>, <code>expm1</code>, <code>floor</code>, <code>log</code>, <code>log10</code>, <code>log1p</code>, <code>log2</code>, <code>logaddexp</code>, <code>maximum</code>, <code>minimum</code>, <code>negative</code>, <code>power</code>, <code>reciprocal</code>, <code>round</code>, <code>sign</code>, <code>sqrt</code>, <code>square</code>, <code>true_divide</code>, <code>trunc</code> Reduction Operations <code>all</code>, <code>amax</code>, <code>amin</code>, <code>any</code>, <code>average</code>, <code>cumprod</code>, <code>cumsum</code>, <code>max</code>, <code>mean</code>, <code>min</code>, <code>prod</code>, <code>std</code>, <code>sum</code>, <code>var</code> Linear Algebra <code>cross</code>, <code>norm</code>, <code>trace</code> Trigonometric Functions <code>arccos</code>, <code>arccosh</code>, <code>arcsin</code>, <code>arcsinh</code>, <code>arctan</code>, <code>arctan2</code>, <code>arctanh</code>, <code>cos</code>, <code>cosh</code>, <code>sin</code>, <code>sinh</code>, <code>tan</code>, <code>tanh</code>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#prerequisites","title":"Prerequisites","text":""},{"location":"install/#python-39-environment","title":"Python 3.9+ environment","text":"<p>The use of a virtual environment is recommended, and you will need to ensure that the environment use a Python version greater than 3.9. This can be achieved for instance either by using conda or by using pyenv (or pyenv-win on windows) and venv module.</p> <p>The following examples show how to create a virtual environment with Python version 3.10.13 with the mentioned methods.</p>"},{"location":"install/#with-conda-all-platforms","title":"With conda (all platforms)","text":"<pre><code>conda create -n do-env python=3.10.13\nconda activate do-env\n</code></pre>"},{"location":"install/#installation_1","title":"\ud83d\ude80 Installation","text":"<p>You can install KerasCustom using <code>pip</code>:</p> <p>[!IMPORTANT] \ud83d\udea8 Please ensure you install <code>keras_custom</code> to get this library.</p> <pre><code>pip install keras_custom\n</code></pre> <p>Alternatively, to install from source:</p> <pre><code>git clone https://github.com/your-repo/keras_custom.git # Replace with your actual repo URL\ncd keras_custom\npip install .\n</code></pre>"},{"location":"install/#keras","title":"Keras","text":"<p><code>autoroot</code> relies on Keras 3x.</p>"},{"location":"install/#issues","title":"Issues","text":"<p>If you have any issue when installing, you may need to update pip and setuptools:</p> <pre><code>pip install --upgrade pip setuptools\n</code></pre> <p>If still not working, please submit an issue on github.</p>"},{"location":"tutorials/model-splitting/","title":"Model splitting","text":"<p>You are correct. My apologies for the misunderstanding.</p> <p>Here is the raw text for the markdown file. You can copy everything below this line and paste it directly into a text editor and save it as a .md file.</p> <p>\ud83e\udde0 Model Splitting: Creating Nested Models While Maintaining Functionality In this tutorial, we will demonstrate how to split an existing Keras model into a sequence of nested models. The goal is to preserve the same underlying function of the original model but restructure it into smaller, modular components for easier inspection or experimentation.</p>"},{"location":"tutorials/model-splitting/#step-1-setting-up-the-environment","title":"\u2699\ufe0f Step 1: Setting Up the Environment","text":"<p>If you're running this tutorial on Google Colab, follow these steps to install the required libraries and dependencies:</p> <p>Python</p>"},{"location":"tutorials/model-splitting/#on-colab-install-the-library","title":"On Colab: install the library","text":"<p>on_colab = \"google.colab\" in str(get_ipython()) if on_colab:     import sys  # noqa: avoid having this import removed by pycln</p> <pre><code># install dev version for dev doc, or release version for release doc\n!{sys.executable} -m pip install -U pip\n!{sys.executable} -m pip install git+https://github.com/ducoffeM/keras_custom@main#egg=decomon\n# install desired backend (by default torch)\n!{sys.executable} -m pip install \"torch\"\n!{sys.executable} -m pip install \"keras\"\n\n# extra librabry used in this notebook\n!{sys.executable} -m pip install \"numpy\"\n# missing imports IPython\n</code></pre>"},{"location":"tutorials/model-splitting/#step-2-import-required-libraries","title":"\ud83d\udcda Step 2: Import Required Libraries","text":"<p>Next, we import the necessary libraries for our model and image processing.</p> <p>Python</p> <p>import os</p> <p>import keras import keras.backend as K import numpy as np from IPython.display import HTML, Image, display from keras.applications.resnet50 import ResNet50, decode_predictions, preprocess_input from keras.layers import Activation from keras.models import Model, Sequential</p>"},{"location":"tutorials/model-splitting/#step-3-download-and-preprocess-the-image","title":"\ud83d\uddbc\ufe0f Step 3: Download and Preprocess the Image","text":"<p>We will use an image of an elephant for our prediction. If the image file is not present, it will be downloaded from the web.</p> <p>Python</p>"},{"location":"tutorials/model-splitting/#check-if-the-image-is-already-available","title":"Check if the image is already available","text":"<p>if not os.path.isfile(\"elephant.jpg\"):     !wget https://upload.wikimedia.org/wikipedia/commons/f/f9/Zoorashia_elephant.jpg -O elephant.jpg</p>"},{"location":"tutorials/model-splitting/#load-and-preprocess-the-image","title":"Load and preprocess the image","text":"<p>img_path = \"elephant.jpg\" img = keras.utils.load_img(img_path, target_size=(224, 224)) x = keras.utils.img_to_array(img) x = np.expand_dims(x, axis=0)  # Add batch dimension x = preprocess_input(x)  # Preprocess image for ResNet50</p>"},{"location":"tutorials/model-splitting/#step-4-load-the-pre-trained-model","title":"\ud83e\udd16 Step 4: Load the Pre-trained Model","text":"<p>We will use the ResNet50 model pre-trained on ImageNet to make predictions.</p> <p>Python</p>"},{"location":"tutorials/model-splitting/#load-the-resnet50-model-without-the-final-classification-layer","title":"Load the ResNet50 model without the final classification layer","text":"<p>model = ResNet50(weights=\"imagenet\", classifier_activation=None)</p>"},{"location":"tutorials/model-splitting/#make-a-prediction","title":"Make a prediction","text":"<p>preds = model.predict(x)</p>"},{"location":"tutorials/model-splitting/#decode-the-predictions-to-show-the-top-3-predictions","title":"Decode the predictions to show the top 3 predictions","text":"<p>print(\"Predicted:\", decode_predictions(preds, top=3)[0])</p>"},{"location":"tutorials/model-splitting/#step-5-split-the-model-into-nested-models","title":"\ud83d\udd2a Step 5: Split the Model into Nested Models","text":"<p>The goal is to break down the ResNet50 model into smaller, modular nested models. Each nested model will correspond to a part of the original model up to a specific layer. The split will be based on the activations of certain layers.</p> <p>Identify Layers to Split</p> <p>We will first identify the layers with activation functions (ReLU layers) and choose some layers to use as split points. For simplicity, let's pick layers at indices [0, 4, 8, 12, -1].</p> <p>Python</p> <p>import keras_custom from keras_custom.model import get_nested_model</p>"},{"location":"tutorials/model-splitting/#identify-activation-layers-relu-in-the-model","title":"Identify activation layers (ReLU) in the model","text":"<p>relu_name = [     e.name for e in model.layers if isinstance(e, Activation) and e.name.split(\"_\")[-1] == \"out\" ]</p>"},{"location":"tutorials/model-splitting/#select-layers-to-split-at","title":"Select layers to split at","text":"<p>indices = [0, 4, 8, 12, -1] split = [relu_name[i] for i in indices] + [model.layers[-1].name] Create Nested Models</p> <p>Now, we will create a list of nested models by using the selected layers for the splits. Each nested model is built starting from the previous layer.</p> <p>Python</p>"},{"location":"tutorials/model-splitting/#initialize-variables","title":"Initialize variables","text":"<p>layer_in = None input_shape_wo_batch = list(model.input.shape[1:]) nested_models = []</p>"},{"location":"tutorials/model-splitting/#loop-through-the-selected-split-layers-and-create-nested-models","title":"Loop through the selected split layers and create nested models","text":"<p>for name in split:     layer_out = model.get_layer(name)     nested_model = get_nested_model(model, layer_out, layer_in, input_shape_wo_batch)     layer_in = layer_out     nested_models.append(nested_model)</p>"},{"location":"tutorials/model-splitting/#combine-all-nested-models-into-a-sequential-model","title":"Combine all nested models into a Sequential model","text":"<p>model_seq = Sequential(layers=nested_models)</p>"},{"location":"tutorials/model-splitting/#step-6-verify-predictions","title":"\u2705 Step 6: Verify Predictions","text":"<p>We can now check whether the nested model produces the same predictions as the original ResNet50 model.</p> <p>Python</p>"},{"location":"tutorials/model-splitting/#make-predictions-using-the-nested-model-sequence","title":"Make predictions using the nested model sequence","text":"<p>preds_ = model_seq.predict(x)</p>"},{"location":"tutorials/model-splitting/#ensure-the-predictions-are-almost-identical","title":"Ensure the predictions are almost identical","text":"<p>np.testing.assert_almost_equal(preds, preds_)</p>"},{"location":"tutorials/model-splitting/#print-the-prediction-results","title":"Print the prediction results","text":"<p>print(\"Predicted:\", decode_predictions(preds, top=3)[0])</p>"},{"location":"tutorials/model-splitting/#step-7-visualize-the-nested-model-architecture","title":"\ud83d\udcca Step 7: Visualize the Nested Model Architecture","text":"<p>Finally, we can visualize the architecture of the newly created model using Keras' built-in plot_model function.</p> <p>Python</p>"},{"location":"tutorials/model-splitting/#save-model-architecture-visualization-to-a-file","title":"Save model architecture visualization to a file","text":"<p>dot_img_file_backward = \"./ResNet50_nested.png\" keras.utils.plot_model(     model_seq, to_file=dot_img_file_backward, show_shapes=True, show_layer_names=True )</p>"},{"location":"tutorials/model-splitting/#display-the-model-architecture-image","title":"Display the model architecture image","text":"<p>display(     HTML(         ''.format(             dot_img_file_backward         )     ) )</p>"},{"location":"tutorials/model-splitting/#conclusion","title":"\ud83c\udf89 Conclusion","text":"<p>In this tutorial, we successfully split the ResNet50 model into a sequence of nested models. Each nested model corresponds to a portion of the original model, and we verified that the nested models produce the same predictions as the original model. This approach can be useful for visualizing and debugging complex models by breaking them down into smaller components.</p>"},{"location":"tutorials/model-switching/","title":"Model switching","text":"<p>\ud83d\udd04 Tutorial: Switching the data_format in Keras Models In this tutorial, we will demonstrate how to modify the input channel order (i.e., data_format) of a pre-trained Keras model. Specifically, we will swap between the channels_first and channels_last formats, allowing the model to process input images in a different format while maintaining the same underlying functionality.</p> <p>We will also walk you through splitting an existing model into smaller, modular components for easier experimentation.</p> <p>\u2699\ufe0f Step 1: Setting Up the Environment If you're running this tutorial on Google Colab, follow these steps to install the required libraries and dependencies:</p> <p>Python</p>"},{"location":"tutorials/model-switching/#on-colab-install-the-library","title":"On Colab: install the library","text":"<p>on_colab = \"google.colab\" in str(get_ipython()) if on_colab:     import sys  # noqa: avoid having this import removed by pycln</p> <pre><code># install dev version for dev doc, or release version for release doc\n!{sys.executable} -m pip install -U pip\n!{sys.executable} -m pip install git+https://github.com/ducoffeM/keras_custom@main#egg=decomon\n# install desired backend (by default torch)\n!{sys.executable} -m pip install \"torch\"\n!{sys.executable} -m pip install \"keras\"\n\n# extra librabry used in this notebook\n!{sys.executable} -m pip install \"numpy\"\n# missing imports IPython\n</code></pre> <p>\ud83d\udcda Step 2: Import Required Libraries First, we need to import the necessary libraries for model manipulation and image preprocessing.</p> <p>Python</p> <p>import os</p> <p>import keras import numpy as np from IPython.display import HTML, Image, display from keras.applications.resnet50 import ResNet50, decode_predictions, preprocess_input from keras.layers import Activation from keras.models import Model, Sequential \ud83d\uddbc\ufe0f Step 3: Download and Preprocess the Image We will use an image of an elephant for our prediction. If the image file is not present, it will be downloaded from the web.</p> <p>Python</p>"},{"location":"tutorials/model-switching/#check-if-the-image-is-already-available","title":"Check if the image is already available","text":"<p>if not os.path.isfile(\"elephant.jpg\"):     !wget https://upload.wikimedia.org/wikipedia/commons/f/f9/Zoorashia_elephant.jpg -O elephant.jpg</p>"},{"location":"tutorials/model-switching/#load-and-preprocess-the-image","title":"Load and preprocess the image","text":"<p>img_path = \"elephant.jpg\" img = keras.utils.load_img(img_path, target_size=(224, 224)) x = keras.utils.img_to_array(img) x = np.expand_dims(x, axis=0)  # Add batch dimension x = preprocess_input(x)  # Preprocess image for ResNet50 \ud83e\udd16 Step 4: Load the Pre-trained Model Next, we load the pre-trained ResNet50 model without the final classification layer. This allows us to use the model for feature extraction or to make predictions without the final dense layer.</p> <p>Python</p>"},{"location":"tutorials/model-switching/#load-the-resnet50-model-without-the-final-classification-layer","title":"Load the ResNet50 model without the final classification layer","text":"<p>model = ResNet50(weights=\"imagenet\", classifier_activation=None)</p>"},{"location":"tutorials/model-switching/#make-a-prediction","title":"Make a prediction","text":"<p>preds = model.predict(x)</p>"},{"location":"tutorials/model-switching/#decode-the-predictions-to-show-the-top-3-predictions","title":"Decode the predictions to show the top 3 predictions","text":"<p>print(\"Predicted:\", decode_predictions(preds, top=3)[0]) \u2194\ufe0f Step 5: Switch the Input Channel Format In this step, we will modify the input channel format of the model. Specifically, we will switch between channels_first and channels_last. This is useful when you need to work with models built with different channel order conventions.</p> <p>We will use a custom utility function switch_model_input_channel, which handles this transformation.</p> <p>Python</p> <p>def get_data_format(model):     for layer in model.layers:         if hasattr(layer, \"data_format\"):             return layer.data_format     return \"channels_first\" Python</p> <p>from keras_custom.model.channel import switch_model_input_channel</p> <p>original_data_format = get_data_format(model)</p>"},{"location":"tutorials/model-switching/#switch-the-channel-format-of-the-model-to-channels_last","title":"Switch the channel format of the model to 'channels_last'","text":"<p>model_last, _ = switch_model_input_channel(model, original_data_format)</p>"},{"location":"tutorials/model-switching/#permute-the-input-image-to-match-the-channels_last-format","title":"Permute the input image to match the 'channels_last' format","text":"<p>if original_data_format == \"channels_first\":     y = np.transpose(         x, (0, 2, 3, 1)     )  # Change the dimensions to (batch_size, height, width, channel) else:     y = np.transpose(         x, (0, 3, 1, 2)     )  # Change the dimensions to (batch_size, channel, height, width)</p>"},{"location":"tutorials/model-switching/#make-a-prediction-with-the-modified-model","title":"Make a prediction with the modified model","text":"<p>preds_ = model_last.predict(y)</p> <p>np.testing.assert_almost_equal(preds, preds_, decimal=5) Python</p>"},{"location":"tutorials/model-switching/#decode-the-predictions-to-show-the-top-3-predictions_1","title":"Decode the predictions to show the top 3 predictions","text":"<p>print(\"Predicted (with switched channel format):\", decode_predictions(preds_, top=3)[0]) Key Points: The switch_model_input_channel function swaps the channel format of the model.</p> <p>We use np.transpose to reorder the image dimensions, switching from (batch_size, height, width, channels) to (batch_size, channels, height, width) for channels_first.</p> <p>After modifying the model, we make a prediction using the transformed model.</p> <p>\ud83c\udf89 Conclusion In this tutorial, we demonstrated how to:</p> <p>Load and preprocess an image for use with a pre-trained Keras model.</p> <p>Use ResNet50 to make predictions on the image.</p> <p>Modify the input channel format (channels_first to channels_last and vice versa) for the model using a custom utility function.</p> <p>Apply the necessary transformations to the input tensor to match the new channel format and make predictions.</p> <p>This approach allows you to experiment with different input formats for your Keras models without modifying the underlying architecture, making it a useful technique for working with models in different environments or frameworks.</p>"}]}